<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>场景世界坐标转</title>
		<style type="text/css">
			html,
			body {
				margin: 0;
				height: 100%;
			}
			
			canvas {
				display: block;
			}
			
			.title {
				position: absolute;
				padding: 10px;
				background: rgba(255, 255, 255, 0.5);
				line-height: 1;
				border-radius: 5px;
			}
		</style>
		<script type="text/javascript" src="libs/three.js"></script>
		<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
		<script src="https://johnson2heng.github.io/three.js-demo/lib/js/controls/OrbitControls.js"></script>
		<script src="https://johnson2heng.github.io/three.js-demo/lib/js/libs/stats.min.js"></script>
		<script src="https://johnson2heng.github.io/three.js-demo/lib/js/libs/dat.gui.min.js"></script>
	</head>
	<body>
		<div class="title one">第一个盒子</div>
		<div class="title two">第二个盒子</div>
		<div class="title three">第三个盒子</div>
	</body>
	<script>
		var renderer, camera, scene, gui, light, stats, controls;
		var cube, cube2, cube3;
		function initRender() {
			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
		//	renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0xeeeeee);
			//renderer.shadowMap.enabled = true;
			//告诉渲染器需要阴影效果
			document.body.appendChild(renderer.domElement);
		}

		function initCamera() {
			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.set(0, 0, 15);
		}

		function initScene() {
			//给场景添加天空盒子纹理
			var cubeTextureLoader = new THREE.CubeTextureLoader();
			cubeTextureLoader.setPath('/lib/textures/cube/space/');
			//六张图片分别是朝前的（posz）、朝后的（negz）、朝上的（posy）、朝下的（negy）、朝右的（posx）和朝左的（negx）。
			var cubeTexture = cubeTextureLoader.load([
				'right.jpg', 'left.jpg',
				'top.jpg', 'bottom.jpg',
				'front.jpg', 'back.jpg'
			]);

			scene = new THREE.Scene();

			scene.background = cubeTexture;
		}

		//初始化dat.GUI简化试验流程
		function initGui() {
			//声明一个保存需求修改的相关数据的对象
			gui = {};
			var datGui = new dat.GUI();
			//将设置属性添加到gui当中，gui.add(对象，属性，最小值，最大值）
		}

		function initLight() {
			scene.add(new THREE.AmbientLight(0x444444));

			light = new THREE.DirectionalLight(0xffffff);
			light.position.set(0, 20, 20);

			light.castShadow = true;
			light.shadow.camera.top = 10;
			light.shadow.camera.bottom = -10;
			light.shadow.camera.left = -10;
			light.shadow.camera.right = 10;

			//告诉平行光需要开启阴影投射
			light.castShadow = true;

			scene.add(light);
		}

		function initModel() {

			//辅助工具
			var helper = new THREE.AxesHelper(50);
			scene.add(helper);

			var material = new THREE.MeshStandardMaterial({
				color: 0x00ffff
			});

			//添加立方体
			var geometry = new THREE.BoxBufferGeometry(1, 1, 1);

			//添加第一个
			cube = new THREE.Mesh(geometry, material);
			scene.add(cube);

			//添加第二个
			cube2 = new THREE.Mesh(geometry, material);
			cube2.position.set(3, 3, -2);
			scene.add(cube2);

			//添加第三个
			cube3 = new THREE.Mesh(geometry, material);
			cube3.position.set(-3, 3, 2);
			scene.add(cube3);

		}

		//初始化性能插件
		function initStats() {
			stats = new Stats();
			document.body.appendChild(stats.dom);
		}

		function initControls() {

			controls = new THREE.OrbitControls(camera, renderer.domElement);
			//设置控制器的中心点
			//controls.target.set( 0, 5, 0 );
			// 如果使用animate方法时，将此函数删除
			//controls.addEventListener( 'change', render );
			// 使动画循环使用时阻尼或自转 意思是否有惯性
			controls.enableDamping = true;
			//动态阻尼系数 就是鼠标拖拽旋转灵敏度
			//controls.dampingFactor = 0.25;
			//是否可以缩放
			controls.enableZoom = true;
			//是否自动旋转
			controls.autoRotate = false;
			controls.autoRotateSpeed = 0.5;
			//设置相机距离原点的最远距离
			controls.minDistance = 1;
			//设置相机距离原点的最远距离
			controls.maxDistance = 2000;
			//是否开启右键拖拽
			controls.enablePan = true;
		}

		//每帧额外的运算
		function render() {
			//获取到窗口的一半高度和一半宽度
			let halfWidth = window.innerWidth / 2;
			let halfHeight = window.innerHeight / 2;

			let vector1 = cube.position.clone().project(camera);
			let vector2 = cube2.position.clone().project(camera);
			let vector3 = cube3.position.clone().project(camera);

			//修改第一个的div的位置
			$(".one").css({
				left: vector1.x * halfWidth + halfWidth,
				top: -vector1.y * halfHeight + halfHeight
			});

			$(".two").css({
				left: vector2.x * halfWidth + halfWidth,
				top: -vector2.y * halfHeight + halfHeight
			});

			$(".three").css({
				left: vector3.x * halfWidth + halfWidth,
				top: -vector3.y * halfHeight + halfHeight
			});

		}

		//窗口变动触发的函数
		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function animate() {
			//每帧额外的运算
			render();

			//更新性能插件
			stats.update();

			controls.update();

			renderer.render(scene, camera);

			requestAnimationFrame(animate);
		}

		function draw() {
			console.log('gggggggggg')
			//兼容性判断
			initGui();
			initRender();
			initScene();
			initCamera();
			initLight();
			initModel();
			initControls();
			initStats();

			animate();
			window.onresize = onWindowResize;
		}
		draw()
	</script>

</html>

<!--<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style type="text/css">
        html, body {
            margin: 0;
            height: 100%;
        }

        canvas {
            display: block;
        }

    </style>
</head>
<body onload="draw();">

</body>
<script src="https://johnson2heng.github.io/three.js-demo/lib/three.js"></script>
<script src="https://johnson2heng.github.io/three.js-demo/lib/js/controls/OrbitControls.js"></script>
<script src="https://johnson2heng.github.io/three.js-demo/lib/js/libs/stats.min.js"></script>
<script src="https://johnson2heng.github.io/three.js-demo/lib/js/libs/dat.gui.min.js"></script>
<script>
    var renderer;

    function initRender() {
        renderer = new THREE.WebGLRenderer({antialias: true,alpha:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        //告诉渲染器需要阴影效果
        //renderer.shadowMap.enabled = true;
        //renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 默认的是，没有设置的这个清晰 THREE.PCFShadowMap
        renderer.setClearColor(0xffffff);
        document.body.appendChild(renderer.domElement);
    }

    var camera;

    function initCamera() {
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 40, 100);
        camera.lookAt(new THREE.Vector3(0, 0, 0));
    }

    var scene;

    function initScene() {
        scene = new THREE.Scene();
    }

    function initLight() {

    }

    function initModel() {

        //辅助工具
        var helper = new THREE.AxesHelper(10);
        scene.add(helper);

        var s = 25;

        var cube = new THREE.CubeGeometry(s, s, s);

        for (var i = 0; i < 3000; i++) {

            var material = new THREE.MeshBasicMaterial({color:randomColor()});

            var mesh = new THREE.Mesh(cube, material);

            mesh.position.x = 800 * ( 2.0 * Math.random() - 1.0 );
            mesh.position.y = 800 * ( 2.0 * Math.random() - 1.0 );
            mesh.position.z = 800 * ( 2.0 * Math.random() - 1.0 );

            mesh.rotation.x = Math.random() * Math.PI;
            mesh.rotation.y = Math.random() * Math.PI;
            mesh.rotation.z = Math.random() * Math.PI;

            mesh.updateMatrix();

            scene.add(mesh);

        }

    }

    //随机生成颜色
    function randomColor() {
        var arrHex = ["0","1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d","e","f"],
            strHex = "#",
            index;
        for(var i = 0; i < 6; i++) {
            index = Math.round(Math.random() * 15);
            strHex += arrHex[index];
        }
        return strHex;
    }

    //声明raycaster和mouse变量
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();

    function onMouseClick( event ) {

        //通过鼠标点击的位置计算出raycaster所需要的点的位置，以屏幕中心为原点，值的范围为-1到1.

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        // 通过鼠标点的位置和当前相机的矩阵计算出raycaster
        raycaster.setFromCamera( mouse, camera );

        // 获取raycaster直线和所有模型相交的数组集合
        var intersects = raycaster.intersectObjects( scene.children );

        console.log(intersects);

        //将所有的相交的模型的颜色设置为红色，如果只需要将第一个触发事件，那就数组的第一个模型改变颜色即可
        for ( var i = 0; i < intersects.length; i++ ) {

            intersects[ i ].object.material.color.set( 0xff0000 );

        }

    }

    window.addEventListener( 'click', onMouseClick, false );

    //初始化dat.GUI简化试验流程
    var gui;

    function initGui() {
        //声明一个保存需求修改的相关数据的对象
        controls = {

        };

        var gui = new dat.GUI();

    }

    //初始化性能插件
    var stats;

    function initStats() {
        stats = new Stats();
        document.body.appendChild(stats.dom);
    }

    //用户交互插件 鼠标左键按住旋转，右键按住平移，滚轮缩放
    var controls;

    function initControls() {

        controls = new THREE.OrbitControls(camera, renderer.domElement);

        // 如果使用animate方法时，将此函数删除
        //controls.addEventListener( 'change', render );
        // 使动画循环使用时阻尼或自转 意思是否有惯性
        controls.enableDamping = true;
        //动态阻尼系数 就是鼠标拖拽旋转灵敏度
        //controls.dampingFactor = 0.25;
        //是否可以缩放
        controls.enableZoom = true;
        //是否自动旋转
        controls.autoRotate = false;
        //设置相机距离原点的最远距离
        controls.minDistance = 50;
        //设置相机距离原点的最远距离
        controls.maxDistance = 200;
        //是否开启右键拖拽
        controls.enablePan = true;
    }

    function render() {
        renderer.render(scene, camera);
    }

    //窗口变动触发的函数
    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        render();
        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    function animate() {
        //更新控制器
        render();

        //更新性能插件
        stats.update();

        //controls.update();

        requestAnimationFrame(animate);
    }

    function draw() {
        initRender();
        initScene();
        initCamera();
        initLight();
        initModel();
        initGui();
        initControls();
        initStats();

        animate();
        window.onresize = onWindowResize;
    }
</script>
</html>-->